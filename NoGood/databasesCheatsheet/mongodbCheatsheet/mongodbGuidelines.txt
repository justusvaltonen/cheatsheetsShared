
############################################
## How to design the structure of your DB ##
############################################

https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design	--> (1) Best practices
https://mongoosejs.com/docs/populate.html					--> (2) Building from a reference

_____________________
-- New Terminology --
---------------------

A)
Application-level join	-->
Atomic			-->

D)
Denormalization		--> (1): "Appendix I: What is database denormalization?"

E)
Embedding		--> Possibly the same as hardcoding.

H)
High-cardinality array	-->

I)
Index			-->

N)
Non-relational database	-->
NormalizedDatabase
 SQL

P)
Projection specifier	-->

R)
Redundant data		--> Duplicated on Azure, not sure about here.
Relational database	-->

S)
Server-side join	-->



___________________
-- (1) Guide (1) --
-------------------
-To me it seems that these six rules are not to be used on nosql only, but in many fields of CS.
-When looking at the first rule, this looks like a priority list.

Six Rules:
1) Favor embedding unless there is a compelling reason not to.

2) Needing to access an object on its own is a compelling reason not to embed it.

3) Arrays should not grow without bound. If there are more than a couple of hundred documents on the “many” side, don’t embed them; if there are more than a few thousand documents on the “many” side, don’t use an array of ObjectID references. High-cardinality arrays are a compelling reason not to embed.

4) Don’t be afraid of application-level joins: If you index correctly and use the projection specifier, then application-level joins are barely more expensive than server-side joins in a relational database.

5) Consider the read-to-write ratio with denormalization. A field that will mostly be read and only seldom updated is a good candidate for denormalization. If you denormalize a field that is updated frequently then the extra work of finding and updating all the instances of redundant data is likely to overwhelm the savings that you get from denormalization.

6) As always with MongoDB, how you model your data depends entirely on your particular application’s data access patterns. You want to structure your data to match the ways that your application queries and updates it.


##########################################
##		Examples 		##
##########################################

(Ex.1)(1)
one-to-few, one-to-many, one-to-squillions

ObjectOneToFew		--> In many cases these are truely unique objects. Embedded things are not used in any other things in the code
 ID
 EmbeddedThingsArray
  ThingOne		--> No need for an ID for these. Only used in this Object
  ThingTwo
  ThingThree
  
ObjectOneToMany
 ID
 EmbeddedThings
  ThingFour
  ThingFive
 Properties
  *PropertiesTemplate
   *SomeRandomPropertyThatGetsPopulatedHere
   *OtherThingThatGetsPopulatedHere
   *ThisRepresentsALongListOfReferences

ObjectOneToSquillions			--> Not storing even all of the pointers, but relying on a treeStructure? Can also have a pointer to an array of pointers if they execute the same way always.
 ID					--> Child elements will have the parents address always available. This enables some features to be used structure wise.
 ParentID				--> If blank, this is the ancestor.
 EmbeddedThingsArray
 LongListOfChildElements
  Function(ID, Next, Last)		--> Possibly there is a hint of recursive calling method. Some sort of datastructurethings going on. Hard to grasp before implementing


